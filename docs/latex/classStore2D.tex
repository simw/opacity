\section{Store2D Class Reference}
\label{classStore2D}\index{Store2D@{Store2D}}
{\tt \#include $<$store.h$>$}

\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
{\bf Store2D} ()
\item 
{\bf Store2D} (long SizeDim1\_\-, long SizeDim2\_\-, long SizePerPoint\_\-)
\begin{CompactList}\small\item\em Constructor, supplying the dimensions of the store grid. \item\end{CompactList}\item 
void {\bf SetParameters} ({\bf Parameters} \&inParams)
\item 
int {\bf ReadFromFile} (std::string FileName\_\-)
\item 
void {\bf WriteToFile} (std::string FileName\_\-, bool append)
\begin{CompactList}\small\item\em Write everything to file. \item\end{CompactList}\item 
int {\bf SetSize} (long Size1\_\-, long Size2\_\-, long SizePerPoint\_\-)
\begin{CompactList}\small\item\em Resize the store. \item\end{CompactList}\item 
void {\bf SetLimitsDim1} (double MinDim1\_\-, double MaxDim1\_\-)
\begin{CompactList}\small\item\em Set the limits in dimension 1. \item\end{CompactList}\item 
void {\bf SetLimitsDim2} (double MinDim2\_\-, double MaxDim2\_\-)
\begin{CompactList}\small\item\em Set the limits in dimension 2. \item\end{CompactList}\item 
void {\bf AddPoint} (long IndexDim1\_\-, long IndexDim2\_\-, MyArray \&Values\_\-)
\item 
double {\bf GetCoordDim1} (long IndexDim1\_\-) const 
\begin{CompactList}\small\item\em Get the coordinate in dimension 1 corresponding to the given index. \item\end{CompactList}\item 
double {\bf GetCoordDim2} (long IndexDim2\_\-) const 
\begin{CompactList}\small\item\em Get the coordinate in dimension 2 corresponding to the given index. \item\end{CompactList}\item 
void {\bf GetCoords} (long IndexDim1\_\-, long IndexDim2\_\-, double \&ValDim1, double \&ValDim2) const 
\begin{CompactList}\small\item\em Get the 2D coordinates corresponding to the given indices. \item\end{CompactList}\item 
long {\bf GetLengthDim1} () const 
\item 
long {\bf GetLengthDim2} () const 
\item 
long {\bf GetNumIterations} (long opac, long kth, long xth)
\end{CompactItemize}
\subsection*{Private Member Functions}
\begin{CompactItemize}
\item 
long {\bf GetIndex} (long IndexDim1, long IndexDim2) const 
\begin{CompactList}\small\item\em Helper function to turn (IndexDim1,IndexDim2) into a 1D index. \item\end{CompactList}\end{CompactItemize}
\subsection*{Private Attributes}
\begin{CompactItemize}
\item 
long {\bf SizeDim1}
\begin{CompactList}\small\item\em The number of points in dimension 1, excluding the starting point. \item\end{CompactList}\item 
double {\bf MinDim1}
\begin{CompactList}\small\item\em The Starting point of dimension 1. \item\end{CompactList}\item 
double {\bf MaxDim1}
\begin{CompactList}\small\item\em The finishing point of dimension 1. \item\end{CompactList}\item 
double {\bf StepDim1}
\item 
long {\bf SizeDim2}
\begin{CompactList}\small\item\em The number of points in dimension 2, excluding the starting point. \item\end{CompactList}\item 
double {\bf MinDim2}
\begin{CompactList}\small\item\em The Starting point of dimension 2. \item\end{CompactList}\item 
double {\bf MaxDim2}
\begin{CompactList}\small\item\em The finishing point of dimension 2. \item\end{CompactList}\item 
double {\bf StepDim2}
\item 
long {\bf SizePerPoint}
\begin{CompactList}\small\item\em The size of the array of information for each point. \item\end{CompactList}\item 
boost::multi\_\-array$<$ {\bf Wrapper}$<$ {\bf StatisticsMC} $>$, 2 $>$ {\bf stats}
\end{CompactItemize}
\subsection*{Friends}
\begin{CompactItemize}
\item 
std::ostream \& {\bf operator$<$$<$} (std::ostream \&out, const {\bf Store2D} \&store)
\begin{CompactList}\small\item\em friend to $<$$<$ so that we can overload it to output a \doxyref{Store2D}{p.}{classStore2D} object \item\end{CompactList}\item 
std::istream \& {\bf operator$>$$>$} (std::istream \&in, {\bf Store2D} \&store)
\end{CompactItemize}


\subsection{Detailed Description}
A two dimensional store of results, with an arbitrary length array of StatisticsMC derived objects for each point. Mechanisms for storage to file and resumption from file are provided. File format: section begins with '\# Begin \doxyref{Store2D}{p.}{classStore2D} data' and ends with '\# End \doxyref{Store2D}{p.}{classStore2D} data'. In between this are all the data point, the number corresponding to the \doxyref{Parameters}{p.}{classParameters} section in the same file (which has already been read). Blank lines and lines beginning with \# are ignored.

Dimension1 = k; Dimension2 = x;

TODO: generalise this class for an arbitrary dimension result. 

Definition at line 29 of file store.h.

\subsection{Constructor \& Destructor Documentation}
\index{Store2D@{Store2D}!Store2D@{Store2D}}
\index{Store2D@{Store2D}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}Store2D::Store2D ()}\label{classStore2D_8f303cd8a1b95729ebb4bc98b7e39432}




Definition at line 13 of file store.cpp.

\begin{Code}\begin{verbatim}14 {
15 
16 }
\end{verbatim}
\end{Code}


\index{Store2D@{Store2D}!Store2D@{Store2D}}
\index{Store2D@{Store2D}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}Store2D::Store2D (long {\em SizeDim1\_\-}, long {\em SizeDim2\_\-}, long {\em SizePerPoint\_\-})}\label{classStore2D_18d5d02a147c7a93d3df5bbe14a399ab}


Constructor, supplying the dimensions of the store grid. 



Definition at line 18 of file store.cpp.

References SetSize().

\begin{Code}\begin{verbatim}19 {
20   SetSize( SizeDim1_, SizeDim2_, SizePerPoint_ );
21 }
\end{verbatim}
\end{Code}




\subsection{Member Function Documentation}
\index{Store2D@{Store2D}!GetIndex@{GetIndex}}
\index{GetIndex@{GetIndex}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}long Store2D::GetIndex (long {\em IndexDim1}, long {\em IndexDim2}) const\hspace{0.3cm}{\tt  [inline, private]}}\label{classStore2D_b44cd7020da6e04cf3b9d8e53fb57b3c}


Helper function to turn (IndexDim1,IndexDim2) into a 1D index. 



Definition at line 113 of file store.h.

References SizeDim2.

Referenced by AddPoint(), GetNumIterations(), operator$<$$<$(), and operator$>$$>$().

\begin{Code}\begin{verbatim}114 {
115   return ( IndexDim1_*(SizeDim2+1) + IndexDim2_ );
116 }
\end{verbatim}
\end{Code}


\index{Store2D@{Store2D}!SetParameters@{SetParameters}}
\index{SetParameters@{SetParameters}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Store2D::SetParameters ({\bf Parameters} \& {\em inParams})}\label{classStore2D_d8d94d26d8090ef21221d3b45363b41a}




Definition at line 23 of file store.cpp.

References Parameters::GetParametersDouble(), SetLimitsDim1(), SetLimitsDim2(), and SetSize().

\begin{Code}\begin{verbatim}24 {
25   std::vector<double> ReturnedParamsDouble1, ReturnedParamsDouble2;
26   std::list<std::string> ReturnedParamsString;  
27 
28   // First, get the details from the parameters object
29   double min1, max1, min2, max2;
30   long size1, size2;
31   ReturnedParamsDouble1 = MyParameters.GetParametersDouble( "@storedim1" );
32   if ( ReturnedParamsDouble1.size() < 3 )
33     std::cerr << "Error with @storedim1" << std::endl;
34   ReturnedParamsDouble2 = MyParameters.GetParametersDouble( "@storedim2" );
35   if ( ReturnedParamsDouble2.size() < 3 )
36     std::cerr << "Error with @storedim2" << std::endl;
37   size1 = long(ReturnedParamsDouble1.at(2)+0.5);
38   size2 = long(ReturnedParamsDouble2[2]+0.5);
39   min1 = ReturnedParamsDouble1[0];
40   min2 = ReturnedParamsDouble2[0];
41   max1 = ReturnedParamsDouble1[1];
42   max2 = ReturnedParamsDouble2[1];
43 
44   SetSize( size1, size2, 1 );
45   SetLimitsDim1( ReturnedParamsDouble1[0], ReturnedParamsDouble1[1] );
46   SetLimitsDim2( ReturnedParamsDouble2[0], ReturnedParamsDouble2[1] );
47 }
\end{verbatim}
\end{Code}


\index{Store2D@{Store2D}!ReadFromFile@{ReadFromFile}}
\index{ReadFromFile@{ReadFromFile}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Store2D::ReadFromFile (std::string {\em FileName\_\-})}\label{classStore2D_439adcb475b85255da8b9444a4d15fe0}


Get all the store data from a file, and resume from that point \begin{Desc}
\item[Returns:]Integer error code: either 0, or negative number indicating error \end{Desc}


Definition at line 101 of file store.cpp.

\begin{Code}\begin{verbatim}102 {
103   // Reading in a file, and putting it in the store
104   // The code here is very similar to that in the parameters.cpp for reading
105   // in the parameters from a file
106 
107   // First, we open the file and check that it exists
108   std::ifstream FileIn;
109   FileIn.open( FileName_.c_str(), std::ios::in );
110   if ( FileIn.fail() )
111   {
112     std::cerr << "Store2D, unable to open file " << FileName_;
113     std::cerr << " for reading." << std::endl;
114     return -20;
115   }
116 
117   // Each line, we'll read into LineReadIn
118   // Each line of settings will be counted in NumberOfLines
119   std::string LineReadIn;
120 
121   // Ok, we have an open file, we want to find the data section
122   // The string that identifies the beginning of the settings section
123   std::string BeginString = "# Begin Store2D data";
124   // The string that identifies the end of the settings section
125   std::string EndString = "# End Store2D data";
126 
127   // Indicator whether we have found the settings section yet
128   bool FoundStart;
129   // Run through the file until we find the settings section
130   do
131   {
132     if ( FileIn.eof() )
133     {
134       std::cerr << "Store2D, reached end of file at line before "; 
135       std::cerr << "finding data section" << std::endl;
136       return -21;
137     }
138     getline( FileIn, LineReadIn );
139     boost::trim( LineReadIn );
140     if ( LineReadIn == BeginString )
141       FoundStart = true;
142   }
143   while ( !FoundStart );
144 
145   // Now, pass off the logic to the >> operator
146   FileIn >> *this;
147 
148   // Now we're done, we close the file
149   FileIn.close();
150   
151   // Everything has worked fine. 
152   // Return a success code
153   return 0;
154 }
\end{verbatim}
\end{Code}


\index{Store2D@{Store2D}!WriteToFile@{WriteToFile}}
\index{WriteToFile@{WriteToFile}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Store2D::WriteToFile (std::string {\em FileName\_\-}, bool {\em append})}\label{classStore2D_44ca03413f3add88b089d5ca5e2db146}


Write everything to file. 



Definition at line 156 of file store.cpp.

\begin{Code}\begin{verbatim}157 {
158   // First, open the file
159   std::ofstream FileOut;
160   if ( append )
161   {
162     FileOut.open( FileName_.c_str(), std::ios::app );
163   }
164   else
165   {
166     FileOut.open( FileName_.c_str(), std::ios::trunc );
167   }
168   
169   // Check for errors
170   if ( FileOut.fail() )
171   {
172     std::cerr << "Store2D, unable to open file " << FileName_;
173     std::cerr << " for writing." << std::endl;
174   }
175 
176   FileOut << "# Begin Store2D data" << std::endl;
177   FileOut << *this;
178   FileOut << "# End Store2D data" << std::endl;
179   FileOut.close();
180 }
\end{verbatim}
\end{Code}


\index{Store2D@{Store2D}!SetSize@{SetSize}}
\index{SetSize@{SetSize}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Store2D::SetSize (long {\em Size1\_\-}, long {\em Size2\_\-}, long {\em SizePerPoint\_\-})}\label{classStore2D_603637865cf139ab0ba16d4209231db0}


Resize the store. 



Definition at line 49 of file store.cpp.

References SizeDim1, SizeDim2, SizePerPoint, and stats.

Referenced by SetParameters(), and Store2D().

\begin{Code}\begin{verbatim}50 {
51   SizeDim1 = Size1_;
52   SizeDim2 = Size2_;
53   SizePerPoint = SizePerPoint_;
54 
55   stats.resize( boost::extents[ (SizeDim1+1)*(SizeDim2+1) ][SizePerPoint] );
56 
57   // We want to set up all the StatisticsMC as pointers to
58   // ConvergenceTable objects containing StatisticsMean objects
59   StatisticsMean gatherer;
60   ConvergenceTable tab(gatherer);
61 
62   for (long i=0; i!=(SizeDim1+1)*(SizeDim2+1); ++i)
63     for (long opac=0; opac!=SizePerPoint; ++opac)
64       stats[i][opac] = tab;
65 
66   return 0;
67 }
\end{verbatim}
\end{Code}


\index{Store2D@{Store2D}!SetLimitsDim1@{SetLimitsDim1}}
\index{SetLimitsDim1@{SetLimitsDim1}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Store2D::SetLimitsDim1 (double {\em MinDim1\_\-}, double {\em MaxDim1\_\-})}\label{classStore2D_f5e242a3890d45693b57c29604b95c6c}


Set the limits in dimension 1. 



Definition at line 69 of file store.cpp.

References MaxDim1, MinDim1, SizeDim1, and StepDim1.

Referenced by SetParameters().

\begin{Code}\begin{verbatim}70 {
71   MinDim1 = MinDim1_;
72   MaxDim1 = MaxDim1_;
73   // For convenience, we calculate the fixed step size and store it
74   StepDim1 = (MaxDim1-MinDim1)/double(SizeDim1);
75 }
\end{verbatim}
\end{Code}


\index{Store2D@{Store2D}!SetLimitsDim2@{SetLimitsDim2}}
\index{SetLimitsDim2@{SetLimitsDim2}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Store2D::SetLimitsDim2 (double {\em MinDim2\_\-}, double {\em MaxDim2\_\-})}\label{classStore2D_3bfb842289b901099cb616887ae07d7f}


Set the limits in dimension 2. 



Definition at line 77 of file store.cpp.

References MaxDim2, MinDim2, SizeDim2, and StepDim2.

Referenced by SetParameters().

\begin{Code}\begin{verbatim}78 {
79   MinDim2 = MinDim2_;
80   MaxDim2 = MaxDim2_;
81   // For convenience, we calculate the fixed step size and store it
82   StepDim2 = (MaxDim2_-MinDim2_)/static_cast<double>(SizeDim2);
83 }
\end{verbatim}
\end{Code}


\index{Store2D@{Store2D}!AddPoint@{AddPoint}}
\index{AddPoint@{AddPoint}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Store2D::AddPoint (long {\em IndexDim1\_\-}, long {\em IndexDim2\_\-}, MyArray \& {\em Values\_\-})}\label{classStore2D_ca7474c53986ddae6f781ed9d41301b0}


Add a new Monte Carlo point to our results - at (IndexDim1\_\-,IndexDim2\_\-) with an array of values given by Values\_\- 

Definition at line 85 of file store.cpp.

References GetIndex(), SizePerPoint, and stats.

\begin{Code}\begin{verbatim}86 {
87   for (long i=0; i<SizePerPoint; ++i)
88     stats[GetIndex( IndexDim1_, IndexDim2_ )][i]->AddOneResult( Values_[i] );
89 }
\end{verbatim}
\end{Code}


\index{Store2D@{Store2D}!GetCoordDim1@{GetCoordDim1}}
\index{GetCoordDim1@{GetCoordDim1}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}double Store2D::GetCoordDim1 (long {\em IndexDim1\_\-}) const\hspace{0.3cm}{\tt  [inline]}}\label{classStore2D_6b39f08dc385f5a50c18e9d6cbe87050}


Get the coordinate in dimension 1 corresponding to the given index. 



Definition at line 118 of file store.h.

References MinDim1, and StepDim1.

Referenced by GetCoords(), and operator$<$$<$().

\begin{Code}\begin{verbatim}119 {
120   return ( MinDim1 + static_cast<double>(IndexDim1_) * StepDim1 );
121 }
\end{verbatim}
\end{Code}


\index{Store2D@{Store2D}!GetCoordDim2@{GetCoordDim2}}
\index{GetCoordDim2@{GetCoordDim2}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}double Store2D::GetCoordDim2 (long {\em IndexDim2\_\-}) const\hspace{0.3cm}{\tt  [inline]}}\label{classStore2D_1b37ab846af3f6d9568a8e397e172ad1}


Get the coordinate in dimension 2 corresponding to the given index. 



Definition at line 123 of file store.h.

References MinDim2, and StepDim2.

Referenced by GetCoords(), and operator$<$$<$().

\begin{Code}\begin{verbatim}124 {
125   return ( MinDim2 + static_cast<double>(IndexDim2_) * StepDim2 );
126 }
\end{verbatim}
\end{Code}


\index{Store2D@{Store2D}!GetCoords@{GetCoords}}
\index{GetCoords@{GetCoords}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Store2D::GetCoords (long {\em IndexDim1\_\-}, long {\em IndexDim2\_\-}, double \& {\em ValDim1}, double \& {\em ValDim2}) const\hspace{0.3cm}{\tt  [inline]}}\label{classStore2D_3592300d59dc260078f9812de27766c1}


Get the 2D coordinates corresponding to the given indices. 



Definition at line 128 of file store.h.

References GetCoordDim1(), and GetCoordDim2().

\begin{Code}\begin{verbatim}130 {
131   ValDim1 = GetCoordDim1( IndexDim1_ );
132   ValDim2 = GetCoordDim2( IndexDim2_ );
133 }
\end{verbatim}
\end{Code}


\index{Store2D@{Store2D}!GetLengthDim1@{GetLengthDim1}}
\index{GetLengthDim1@{GetLengthDim1}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}long Store2D::GetLengthDim1 () const\hspace{0.3cm}{\tt  [inline]}}\label{classStore2D_f23f90b6e71e144d8943504932e54c63}




Definition at line 135 of file store.h.

References SizeDim1.

\begin{Code}\begin{verbatim}136 {
137   return SizeDim1;
138 }
\end{verbatim}
\end{Code}


\index{Store2D@{Store2D}!GetLengthDim2@{GetLengthDim2}}
\index{GetLengthDim2@{GetLengthDim2}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}long Store2D::GetLengthDim2 () const\hspace{0.3cm}{\tt  [inline]}}\label{classStore2D_d0d940749b30d9cc8649712b62b8bd0b}




Definition at line 140 of file store.h.

References SizeDim2.

\begin{Code}\begin{verbatim}141 {
142   return SizeDim2;
143 }
\end{verbatim}
\end{Code}


\index{Store2D@{Store2D}!GetNumIterations@{GetNumIterations}}
\index{GetNumIterations@{GetNumIterations}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}long Store2D::GetNumIterations (long {\em opac}, long {\em kth}, long {\em xth})}\label{classStore2D_8c7a34cb1e29698174d9d30ca2272ca5}




Definition at line 91 of file store.cpp.

References GetIndex(), and stats.

\begin{Code}\begin{verbatim}92 {
93   std::vector<std::vector<double> > res = 
94         stats[GetIndex( kth, xth )][opac]->GetResultsSoFar();
95   
96   std::vector<std::vector<double> >::iterator it;
97   it = res.end(); --it;
98   return static_cast<long>( it->at(2) );
99 }
\end{verbatim}
\end{Code}




\subsection{Friends And Related Function Documentation}
\index{Store2D@{Store2D}!operator<<@{operator$<$$<$}}
\index{operator<<@{operator$<$$<$}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}std::ostream\& operator$<$$<$ (std::ostream \& {\em out}, const {\bf Store2D} \& {\em store})\hspace{0.3cm}{\tt  [friend]}}\label{classStore2D_9e796d51abbd87d71beadcf2eb5ec49c}


friend to $<$$<$ so that we can overload it to output a \doxyref{Store2D}{p.}{classStore2D} object 



Definition at line 182 of file store.cpp.

\begin{Code}\begin{verbatim}183 {
184   // Assume that all the preliminaries have been written
185   // All we have to do here is write the data to file / stream
186 
187   // Format: dim1 dim2 results....
188   // Incrementing dim1, then dim2
189   
190   // If there are multiple data sets per point, output one whole set then the next
191   // Hence, outer iteration is over data sets per point
192   for (long i=0; i<store.SizePerPoint; ++i)
193   {
194     // Inner iteration over all points
195     for (long dim2=0; dim2<store.SizeDim2; ++dim2)
196     {
197       for (long dim1=0; dim1<store.SizeDim1; ++dim1)
198       {
199         // First, write the k, x coords to file
200         // (for ease of reading either manually or by eg Mathematica)
201         out << store.GetCoordDim1( dim1 ) << " " << store.GetCoordDim2( dim2 ) << " ";
202         // Pass off the logic of writing to the ConvergenceTable object
203         const ConvergenceTable* conTab = static_cast<const ConvergenceTable*>
204                  ( store.stats[ store.GetIndex( dim1, dim2 ) ][i].GetConstPointer() );
205         out << *conTab;
206         out << std::endl;
207       }
208     }
209   }
210 
211   // We're done, all overloading of << has to return the supplied ostream
212   return ( out );
213 }
\end{verbatim}
\end{Code}


\index{Store2D@{Store2D}!operator>>@{operator$>$$>$}}
\index{operator>>@{operator$>$$>$}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}std::istream\& operator$>$$>$ (std::istream \& {\em in}, {\bf Store2D} \& {\em store})\hspace{0.3cm}{\tt  [friend]}}\label{classStore2D_bf866377a8793ea9bde62133d1c1f153}




Definition at line 215 of file store.cpp.

\begin{Code}\begin{verbatim}216 {
217   // TODO: improve this to handle possible alterations to the file
218   // eg blank lines, comment lines etc, handle errors and bad files properly
219 
220   double coordDim1, coordDim2;
221   // Hence, outer iteration is over data sets per point
222   for (long i=0; i<store.SizePerPoint; ++i)
223   {
224     // Inner iteration over all points
225     for (long dim2=0; dim2<store.SizeDim2; ++dim2)
226     {
227       for (long dim1=0; dim1<store.SizeDim1; ++dim1)
228       {
229         // First, we have the coords in dim1 and dim2
230         in >> coordDim1 >> coordDim2;
231         // Pass off the logic of reading to the ConvergenceTable object
232         ConvergenceTable* conTab = static_cast<ConvergenceTable*>
233                  ( store.stats[ store.GetIndex( dim1, dim2 ) ][i].GetPointer() );
234         in >> *conTab;
235       }
236     }
237   }
238 
239   return ( in );
240 }
\end{verbatim}
\end{Code}




\subsection{Member Data Documentation}
\index{Store2D@{Store2D}!SizeDim1@{SizeDim1}}
\index{SizeDim1@{SizeDim1}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}long {\bf Store2D::SizeDim1}\hspace{0.3cm}{\tt  [private]}}\label{classStore2D_57f24bc1891afc382d3f40f037d0aff1}


The number of points in dimension 1, excluding the starting point. 



Definition at line 37 of file store.h.

Referenced by GetLengthDim1(), operator$<$$<$(), operator$>$$>$(), SetLimitsDim1(), and SetSize().\index{Store2D@{Store2D}!MinDim1@{MinDim1}}
\index{MinDim1@{MinDim1}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}double {\bf Store2D::MinDim1}\hspace{0.3cm}{\tt  [private]}}\label{classStore2D_933fc3e6ff97599e8f851c8441c52ef5}


The Starting point of dimension 1. 



Definition at line 39 of file store.h.

Referenced by GetCoordDim1(), and SetLimitsDim1().\index{Store2D@{Store2D}!MaxDim1@{MaxDim1}}
\index{MaxDim1@{MaxDim1}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}double {\bf Store2D::MaxDim1}\hspace{0.3cm}{\tt  [private]}}\label{classStore2D_f14d43ff981525c89d154034154403b2}


The finishing point of dimension 1. 



Definition at line 41 of file store.h.

Referenced by SetLimitsDim1().\index{Store2D@{Store2D}!StepDim1@{StepDim1}}
\index{StepDim1@{StepDim1}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}double {\bf Store2D::StepDim1}\hspace{0.3cm}{\tt  [private]}}\label{classStore2D_16c7e319b97eedbacddec716691a6141}


The step size (derived from Size,Min,Max) in dimension 1, MaxDim1 = MinDim1 + StepDim1 $\ast$ SizeDim1 

Definition at line 45 of file store.h.

Referenced by GetCoordDim1(), and SetLimitsDim1().\index{Store2D@{Store2D}!SizeDim2@{SizeDim2}}
\index{SizeDim2@{SizeDim2}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}long {\bf Store2D::SizeDim2}\hspace{0.3cm}{\tt  [private]}}\label{classStore2D_1aa79281f9314909e1554aac58fe6904}


The number of points in dimension 2, excluding the starting point. 



Definition at line 48 of file store.h.

Referenced by GetIndex(), GetLengthDim2(), operator$<$$<$(), operator$>$$>$(), SetLimitsDim2(), and SetSize().\index{Store2D@{Store2D}!MinDim2@{MinDim2}}
\index{MinDim2@{MinDim2}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}double {\bf Store2D::MinDim2}\hspace{0.3cm}{\tt  [private]}}\label{classStore2D_5fc0b0e1d2a7041be8d4d43e95166ee7}


The Starting point of dimension 2. 



Definition at line 50 of file store.h.

Referenced by GetCoordDim2(), and SetLimitsDim2().\index{Store2D@{Store2D}!MaxDim2@{MaxDim2}}
\index{MaxDim2@{MaxDim2}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}double {\bf Store2D::MaxDim2}\hspace{0.3cm}{\tt  [private]}}\label{classStore2D_c64ee1837967c1c4c485f21d7f7b5f3f}


The finishing point of dimension 2. 



Definition at line 52 of file store.h.

Referenced by SetLimitsDim2().\index{Store2D@{Store2D}!StepDim2@{StepDim2}}
\index{StepDim2@{StepDim2}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}double {\bf Store2D::StepDim2}\hspace{0.3cm}{\tt  [private]}}\label{classStore2D_0f00ac5b6b904b877aa15791e561adef}


The step size (derived from Size,Min,Max) in dimension 2, MaxDim2 = MinDim2 + StepDim2 $\ast$ SizeDim2 

Definition at line 56 of file store.h.

Referenced by GetCoordDim2(), and SetLimitsDim2().\index{Store2D@{Store2D}!SizePerPoint@{SizePerPoint}}
\index{SizePerPoint@{SizePerPoint}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}long {\bf Store2D::SizePerPoint}\hspace{0.3cm}{\tt  [private]}}\label{classStore2D_25ad66b929c4e1f0dd45e0527d5396d0}


The size of the array of information for each point. 



Definition at line 59 of file store.h.

Referenced by AddPoint(), operator$<$$<$(), operator$>$$>$(), and SetSize().\index{Store2D@{Store2D}!stats@{stats}}
\index{stats@{stats}!Store2D@{Store2D}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}boost::multi\_\-array$<${\bf Wrapper}$<${\bf StatisticsMC}$>$, 2 $>$ {\bf Store2D::stats}\hspace{0.3cm}{\tt  [private]}}\label{classStore2D_4f620513ddd183a5c7bf4cac44c9011f}


The array of pointers (wrappers) to Statistics gatherers The first dimension is the 2D store combined into 1 dimension The second dimension corresponds to a size of SizePerPoint 

Definition at line 64 of file store.h.

Referenced by AddPoint(), GetNumIterations(), operator$<$$<$(), operator$>$$>$(), and SetSize().

The documentation for this class was generated from the following files:\begin{CompactItemize}
\item 
Gyulassy/opacity3/src/store2d/{\bf store.h}\item 
Gyulassy/opacity3/src/store2d/{\bf store.cpp}\end{CompactItemize}
